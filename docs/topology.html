<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Topological Trade Dynamics - Phase Transition Detector</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&family=Sora:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Sora', sans-serif;
      background: linear-gradient(135deg, #0a1018 0%, #182433 100%);
      color: #e9eef5;
      overflow: auto;
    }

    nav {
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: blur(12px);
      background: rgba(10, 16, 24, 0.9);
      border-bottom: 1px solid rgba(233, 238, 245, 0.08);
    }

    .nav-container {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 24px;
    }

    .logo {
      font-weight: 700;
      letter-spacing: 0.4px;
      color: #e9eef5;
    }

    nav ul {
      display: flex;
      gap: 18px;
      list-style: none;
      flex-wrap: wrap;
    }

    nav a {
      color: #8a96a8;
      text-decoration: none;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.4px;
      text-transform: uppercase;
    }

    nav a:hover {
      color: #e9eef5;
    }

    .container {
      display: grid;
      grid-template-columns: 320px 1fr;
      min-height: calc(100vh - 64px);
    }

    .sidebar {
      background: rgba(15, 23, 42, 0.95);
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      overflow-y: auto;
      padding: 20px;
    }

    h1 {
      font-size: 22px;
      margin-bottom: 8px;
      background: linear-gradient(135deg, #2f9c95 0%, #f4b34a 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: 700;
    }

    .subtitle {
      font-size: 12px;
      color: #94a3b8;
      margin-bottom: 24px;
      line-height: 1.5;
    }

    .panel {
      background: rgba(30, 41, 59, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
    }

    .panel h2 {
      font-size: 14px;
      color: #cbd5e1;
      margin-bottom: 12px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .panel h2::before {
      content: '';
      width: 3px;
      height: 14px;
      background: linear-gradient(180deg, #60a5fa, #a78bfa);
      border-radius: 2px;
    }

    label {
      display: block;
      font-size: 11px;
      color: #94a3b8;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 500;
    }

    input[type="range"] {
      width: 100%;
      margin-bottom: 16px;
      -webkit-appearance: none;
      height: 4px;
      border-radius: 2px;
      background: rgba(148, 163, 184, 0.2);
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: linear-gradient(135deg, #60a5fa, #a78bfa);
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(96, 165, 250, 0.4);
    }

    .value-display {
      font-size: 13px;
      color: #e9eef5;
      font-family: 'IBM Plex Mono', monospace;
      margin-top: -12px;
      margin-bottom: 12px;
      padding: 6px 10px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
      display: inline-block;
    }

    button {
      width: 100%;
      padding: 12px;
      background: linear-gradient(135deg, #2f9c95 0%, #f4b34a 100%);
      border: none;
      border-radius: 8px;
      color: #0f1825;
      font-size: 13px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(47, 156, 149, 0.35);
    }

    button:active {
      transform: translateY(0);
    }

    button.secondary {
      background: rgba(47, 156, 149, 0.08);
      border: 1px solid rgba(47, 156, 149, 0.4);
      color: #c6f2ea;
    }

    .main-canvas {
      position: relative;
      overflow: hidden;
      min-height: 60vh;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .stats {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px;
      min-width: 250px;
      font-size: 12px;
    }

    .stats h3 {
      font-size: 13px;
      margin-bottom: 12px;
      color: #cbd5e1;
      font-weight: 600;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .stat-row:last-child {
      border-bottom: none;
    }

    .stat-label {
      color: #94a3b8;
    }

    .stat-value {
      color: #e9eef5;
      font-family: 'IBM Plex Mono', monospace;
      font-weight: 600;
    }

    .stat-value.warning {
      color: #f4b34a;
    }

    .stat-value.danger {
      color: #ef4444;
    }

    .stat-value.success {
      color: #10b981;
    }

    .legend {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px;
    }

    .legend h4 {
      font-size: 12px;
      color: #cbd5e1;
      margin-bottom: 12px;
      font-weight: 600;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      font-size: 11px;
    }

    .legend-color {
      width: 20px;
      height: 12px;
      border-radius: 2px;
    }

    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      font-size: 18px;
      color: #2f9c95;
    }

    .data-status {
      margin-top: 8px;
      font-size: 11px;
      color: #94a3b8;
    }

    .spinner {
      border: 3px solid rgba(47, 156, 149, 0.1);
      border-top: 3px solid #2f9c95;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 16px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    select {
      width: 100%;
      padding: 10px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 6px;
      color: #e0e6ed;
      font-size: 12px;
      margin-bottom: 16px;
      cursor: pointer;
    }

    .tooltip {
      position: absolute;
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(96, 165, 250, 0.3);
      border-radius: 8px;
      padding: 12px;
      pointer-events: none;
      display: none;
      font-size: 11px;
      line-height: 1.6;
      max-width: 200px;
      backdrop-filter: blur(10px);
    }

    .info-badge {
      display: inline-block;
      padding: 4px 8px;
      background: rgba(96, 165, 250, 0.15);
      border: 1px solid rgba(96, 165, 250, 0.3);
      border-radius: 4px;
      font-size: 10px;
      color: #60a5fa;
      margin-left: 8px;
      cursor: help;
    }

    @media (max-width: 1100px) {
      .container {
        grid-template-columns: 1fr;
        min-height: auto;
      }

      .sidebar {
        border-right: none;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      }

      .main-canvas {
        min-height: 65vh;
      }

      .stats {
        position: static;
        margin: 16px;
      }

      .legend {
        position: static;
        margin: 0 16px 16px;
      }
    }
  </style>
</head>
<body>
  <nav>
    <div class="nav-container">
      <div class="logo">Gravity Trade Analysis</div>
      <ul>
        <li><a href="landing.html">Home</a></li>
        <li><a href="index.html">Tool</a></li>
        <li><a href="topology.html">Topology</a></li>
        <li><a href="trade-sphere.html">Trade Sphere</a></li>
        <li><a href="trade-map.html">Trade Map</a></li>
        <li><a href="residual-surface.html">Residual Surface</a></li>
        <li><a href="model-lab.html">Model Lab</a></li>
        <li><a href="advanced_topology.html">Research Lab</a></li>
        <li><a href="methodology.html">Methodology</a></li>
        <li><a href="https://github.com/ihelfrich/test_repo">GitHub</a></li>
      </ul>
    </div>
  </nav>
  <div class="container">
    <div class="sidebar">
      <h1>Topological Trade Dynamics</h1>
      <p class="subtitle">
        Real-time phase transition detection using field theory PDEs + persistent homology
      </p>

      <div class="panel">
        <h2>Field Parameters</h2>

        <label>
          Œ∫ (Diffusion) <span class="info-badge" title="Smoothness of trade patterns">?</span>
        </label>
        <input type="range" id="kappa" min="0.0001" max="0.01" step="0.0001" value="0.001">
        <div class="value-display" id="kappa-val">0.001</div>

        <label>
          Œª (Topology) <span class="info-badge" title="Strength of network clustering">?</span>
        </label>
        <input type="range" id="lambda" min="0" max="0.5" step="0.01" value="0.15">
        <div class="value-display" id="lambda-val">0.15</div>

        <label>
          Œ± (Congestion) <span class="info-badge" title="Trade saturation penalty">?</span>
        </label>
        <input type="range" id="alpha" min="0.1" max="5" step="0.1" value="1.0">
        <div class="value-display" id="alpha-val">1.0</div>

        <label>
          Time Step (Œît)
        </label>
        <input type="range" id="dt" min="0.001" max="0.05" step="0.001" value="0.01">
        <div class="value-display" id="dt-val">0.01</div>
      </div>

      <div class="panel">
        <h2>Shock Scenario</h2>

        <label>Year</label>
        <select id="year">
          <option value="2015">2015</option>
          <option value="2016">2016</option>
          <option value="2017">2017</option>
          <option value="2018">2018</option>
          <option value="2019" selected>2019</option>
          <option value="2020">2020 (COVID)</option>
          <option value="2021">2021</option>
        </select>
        <div class="data-status" id="data-status">Loading field data‚Ä¶</div>

        <label>Shock Type</label>
        <select id="shock-type">
          <option value="none">No Shock (Equilibrium)</option>
          <option value="random">Random Perturbation</option>
          <option value="localized">Localized (Region)</option>
          <option value="china">China Supply Shock</option>
          <option value="us-tariff">US Tariff Increase</option>
          <option value="brexit">Brexit Scenario</option>
        </select>

        <label>Shock Magnitude (œÉ)</label>
        <input type="range" id="shock-mag" min="0" max="3" step="0.1" value="0">
        <div class="value-display" id="shock-mag-val">0.0</div>
      </div>

      <div class="panel">
        <h2>Evolution</h2>

        <label>Steps</label>
        <input type="range" id="steps" min="10" max="500" step="10" value="100">
        <div class="value-display" id="steps-val">100</div>

        <button id="evolve-btn">‚ñ∂ Evolve System</button>
        <button id="reset-btn" class="secondary">‚Üª Reset to Equilibrium</button>
      </div>

      <div class="panel">
        <h2>Visualization</h2>

        <label>Colormap</label>
        <select id="colormap">
          <option value="viridis">Viridis (Default)</option>
          <option value="plasma">Plasma</option>
          <option value="inferno">Inferno</option>
          <option value="coolwarm">Coolwarm (Diverging)</option>
          <option value="rdbu">Red-Blue</option>
        </select>

        <label>Show</label>
        <select id="display-mode">
          <option value="field">Field Intensity</option>
          <option value="gradient">Gradient Magnitude</option>
          <option value="laplacian">Laplacian</option>
          <option value="energy">Energy Density</option>
        </select>

        <button id="export-btn" class="secondary">‚Üì Export Data</button>
      </div>
    </div>

    <div class="main-canvas">
      <canvas id="canvas"></canvas>

      <div class="stats">
        <h3>System Diagnostics</h3>
        <div class="stat-row">
          <span class="stat-label">Energy:</span>
          <span class="stat-value" id="energy">-</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">dE/dt:</span>
          <span class="stat-value" id="energy-rate">-</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Autocorrelation:</span>
          <span class="stat-value" id="autocorr">-</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Variance:</span>
          <span class="stat-value" id="variance">-</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Œ≤‚ÇÄ (Components):</span>
          <span class="stat-value" id="betti-0">-</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Œ≤‚ÇÅ (Cycles):</span>
          <span class="stat-value" id="betti-1">-</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Warning Level:</span>
          <span class="stat-value" id="warning">LOW</span>
        </div>
      </div>

      <div class="legend">
        <h4>Field Interpretation</h4>
        <div class="legend-item">
          <div class="legend-color" style="background: linear-gradient(90deg, #440154, #fde724);"></div>
          <span>Low ‚Üí High Trade Intensity</span>
        </div>
        <div class="legend-item" style="margin-top: 12px; font-size: 10px; color: #94a3b8;">
          Patterns indicate clustering, phase transitions, and critical slowing down before network fragmentation.
        </div>
      </div>

      <div class="loading" id="loading" style="display: none;">
        <div class="spinner"></div>
        <div>Evolving field dynamics...</div>
      </div>
    </div>
  </div>

  <div class="tooltip" id="tooltip"></div>

  <script>
    // Data-backed demo with fallback to synthetic fields.
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const dataUrl = new URL('data/topology_fields.json', window.location.href).href;
    const dataStatus = document.getElementById('data-status');
    const yearSelect = document.getElementById('year');

    let field = null;
    let gridSize = 128;
    let useDataField = false;
    let fieldsByYear = {};
    let metaInfo = null;
    let prevField = null;
    let prevEnergy = null;
    let params = {
      kappa: 0.001,
      lambda: 0.15,
      alpha: 1.0,
      dt: 0.01
    };

    // Initialize canvas
    function resizeCanvas() {
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      if (field) drawField();
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function setFieldFromYear(yearKey) {
      const payload = fieldsByYear[yearKey];
      if (!payload || !payload.grid) return false;
      field = payload.grid.map(row => row.map(Number));
      gridSize = field.length;
      prevField = null;
      prevEnergy = null;
      return true;
    }

    // Initialize random field
    function initField() {
      field = new Array(gridSize);
      for (let i = 0; i < gridSize; i++) {
        field[i] = new Array(gridSize);
        for (let j = 0; j < gridSize; j++) {
          field[i][j] = (Math.random() - 0.5) * 0.5;
        }
      }
      prevField = null;
      prevEnergy = null;
    }

    async function loadFieldData() {
      if (window.location.protocol === "file:") {
        dataStatus.textContent = "Serve via web server for data-backed fields.";
        initField();
        drawField();
        updateStats();
        return;
      }

      try {
        const response = await fetch(dataUrl, { cache: "no-store" });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const payload = await response.json();
        metaInfo = payload.meta || {};
        fieldsByYear = payload.fields || {};
        const years = Array.isArray(metaInfo.years)
          ? metaInfo.years
          : Object.keys(fieldsByYear).map(Number).sort((a, b) => a - b);
        if (!years.length) throw new Error("No years in payload");

        yearSelect.innerHTML = "";
        years.forEach((year) => {
          const option = document.createElement("option");
          option.value = year;
          option.textContent = year;
          yearSelect.appendChild(option);
        });

        gridSize = metaInfo.grid_size || gridSize;
        yearSelect.value = years[years.length - 1];
        useDataField = setFieldFromYear(String(yearSelect.value));
        dataStatus.textContent = useDataField
          ? `Loaded data-driven fields (${years.length} years, grid ${gridSize}√ó${gridSize})`
          : "Field data unavailable; using demo mode.";
        drawField();
        updateStats();
      } catch (err) {
        console.warn("Field data load failed:", err);
        dataStatus.textContent = "Demo mode: synthetic field (data not loaded).";
        initField();
        drawField();
        updateStats();
      }
    }

    // Draw field as heatmap
    function drawField() {
      if (!field) return;
      const rect = canvas.getBoundingClientRect();
      const cellW = rect.width / gridSize;
      const cellH = rect.height / gridSize;
      const display = getDisplayField();

      let min = Infinity, max = -Infinity;
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          min = Math.min(min, display[i][j]);
          max = Math.max(max, display[i][j]);
        }
      }

      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          const val = (display[i][j] - min) / (max - min + 1e-10);
          const color = getColormapColor(val);
          ctx.fillStyle = color;
          ctx.fillRect(j * cellW, i * cellH, cellW + 1, cellH + 1);
        }
      }
    }

    const colormapSelect = document.getElementById('colormap');
    const displayMode = document.getElementById('display-mode');

    const COLORMAPS = {
      viridis: [
        [68, 1, 84], [72, 40, 120], [62, 73, 137], [49, 104, 142],
        [38, 130, 142], [31, 158, 137], [53, 183, 121], [110, 206, 88],
        [181, 222, 43], [253, 231, 37]
      ],
      plasma: [
        [13, 8, 135], [70, 3, 159], [113, 1, 168], [156, 23, 158],
        [189, 55, 134], [216, 87, 107], [237, 121, 83], [251, 159, 58],
        [252, 202, 38], [240, 249, 33]
      ],
      inferno: [
        [0, 0, 3], [31, 12, 72], [85, 15, 109], [136, 34, 106],
        [186, 54, 85], [227, 89, 51], [249, 140, 10], [249, 191, 57],
        [252, 233, 131], [252, 255, 164]
      ],
      coolwarm: [
        [59, 76, 192], [68, 90, 204], [77, 104, 215], [87, 117, 225],
        [98, 130, 234], [109, 142, 241], [120, 154, 247], [132, 165, 251],
        [144, 176, 254], [157, 186, 255], [170, 195, 254], [183, 204, 251],
        [196, 211, 245], [209, 217, 238], [221, 221, 221], [231, 206, 200],
        [239, 189, 174], [244, 171, 143], [247, 151, 106], [247, 129, 74],
        [244, 103, 52], [239, 73, 39], [231, 40, 39], [219, 17, 37]
      ],
      rdbu: [
        [5, 48, 97], [33, 102, 172], [67, 147, 195], [146, 197, 222],
        [209, 229, 240], [247, 247, 247], [253, 219, 199], [244, 165, 130],
        [214, 96, 77], [178, 24, 43]
      ]
    };

    function getColormapColor(t) {
      const palette = COLORMAPS[colormapSelect.value] || COLORMAPS.viridis;
      t = Math.max(0, Math.min(1, t));
      const idx = t * (palette.length - 1);
      const i = Math.floor(idx);
      const f = idx - i;
      if (i >= palette.length - 1) return `rgb(${palette[palette.length - 1].join(',')})`;
      const c1 = palette[i];
      const c2 = palette[i + 1];
      const r = Math.round(c1[0] + f * (c2[0] - c1[0]));
      const g = Math.round(c1[1] + f * (c2[1] - c1[1]));
      const b = Math.round(c1[2] + f * (c2[2] - c1[2]));
      return `rgb(${r},${g},${b})`;
    }

    function laplacianAt(source, i, j) {
      const im = (i - 1 + gridSize) % gridSize;
      const ip = (i + 1) % gridSize;
      const jm = (j - 1 + gridSize) % gridSize;
      const jp = (j + 1) % gridSize;
      return source[ip][j] + source[im][j] + source[i][jp] + source[i][jm] - 4 * source[i][j];
    }

    function gradientMagnitude(source, i, j) {
      const im = (i - 1 + gridSize) % gridSize;
      const ip = (i + 1) % gridSize;
      const jm = (j - 1 + gridSize) % gridSize;
      const jp = (j + 1) % gridSize;
      const dx = (source[ip][j] - source[im][j]) * 0.5;
      const dy = (source[i][jp] - source[i][jm]) * 0.5;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function getDisplayField() {
      const mode = displayMode.value;
      if (mode === "field") return field;

      const derived = new Array(gridSize);
      for (let i = 0; i < gridSize; i++) {
        derived[i] = new Array(gridSize);
        for (let j = 0; j < gridSize; j++) {
          if (mode === "gradient") {
            derived[i][j] = gradientMagnitude(field, i, j);
          } else if (mode === "laplacian") {
            derived[i][j] = laplacianAt(field, i, j);
          } else if (mode === "energy") {
            const grad = gradientMagnitude(field, i, j);
            derived[i][j] = 0.5 * params.kappa * grad * grad + 0.25 * params.alpha * Math.pow(field[i][j], 4);
          } else {
            derived[i][j] = field[i][j];
          }
        }
      }
      return derived;
    }

    // Evolve field (simplified)
    function applyShock(type, magnitude) {
      if (!magnitude || magnitude === 0) return;
      const centerMap = {
        localized: [0.5, 0.5],
        china: [0.72, 0.38],
        "us-tariff": [0.25, 0.62],
        brexit: [0.55, 0.72],
      };
      if (type === "random") {
        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            field[i][j] += (Math.random() - 0.5) * 0.2 * magnitude;
          }
        }
        return;
      }
      if (!centerMap[type]) return;
      const [cx, cy] = centerMap[type];
      const sigma = Math.max(2, gridSize * 0.08);
      const cxIdx = cx * (gridSize - 1);
      const cyIdx = cy * (gridSize - 1);
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          const dx = i - cyIdx;
          const dy = j - cxIdx;
          const weight = Math.exp(-(dx * dx + dy * dy) / (2 * sigma * sigma));
          field[i][j] += magnitude * 0.15 * weight;
        }
      }
    }

    function evolveField(steps) {
      document.getElementById('loading').style.display = 'block';
      const shockType = document.getElementById('shock-type').value;
      const shockMag = parseFloat(document.getElementById('shock-mag').value);
      if (shockType !== "none") {
        applyShock(shockType, shockMag);
      }

      setTimeout(() => {
        for (let s = 0; s < steps; s++) {
          const newField = new Array(gridSize);
          for (let i = 0; i < gridSize; i++) {
            newField[i] = new Array(gridSize);
            for (let j = 0; j < gridSize; j++) {
              const laplacian = laplacianAt(field, i, j);
              const topo = (
                -0.05 * field[(i - 1 + gridSize) % gridSize][(j - 1 + gridSize) % gridSize] +
                -0.1 * field[(i - 1 + gridSize) % gridSize][j] +
                -0.05 * field[(i - 1 + gridSize) % gridSize][(j + 1) % gridSize] +
                -0.1 * field[i][(j - 1 + gridSize) % gridSize] +
                1.0 * field[i][j] +
                -0.1 * field[i][(j + 1) % gridSize] +
                -0.05 * field[(i + 1) % gridSize][(j - 1 + gridSize) % gridSize] +
                -0.1 * field[(i + 1) % gridSize][j] +
                -0.05 * field[(i + 1) % gridSize][(j + 1) % gridSize]
              );
              const rhs = params.kappa * laplacian + params.lambda * topo - params.alpha * Math.pow(field[i][j], 3);
              newField[i][j] = field[i][j] + params.dt * rhs;
            }
          }
          field = newField;

          if (s % 10 === 0) {
            updateStats();
            drawField();
          }
        }

        document.getElementById('loading').style.display = 'none';
        updateStats();
        drawField();
      }, 50);
    }

    function flattenField(source) {
      const out = [];
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          out.push(source[i][j]);
        }
      }
      return out;
    }

    function correlation(a, b) {
      if (!a.length || a.length !== b.length) return 0;
      let meanA = 0;
      let meanB = 0;
      for (let i = 0; i < a.length; i++) {
        meanA += a[i];
        meanB += b[i];
      }
      meanA /= a.length;
      meanB /= b.length;
      let num = 0;
      let denA = 0;
      let denB = 0;
      for (let i = 0; i < a.length; i++) {
        const da = a[i] - meanA;
        const db = b[i] - meanB;
        num += da * db;
        denA += da * da;
        denB += db * db;
      }
      const denom = Math.sqrt(denA * denB) || 1;
      return num / denom;
    }

    function countComponents(binary) {
      const visited = Array.from({ length: gridSize }, () => Array(gridSize).fill(false));
      const dirs = [[1,0], [-1,0], [0,1], [0,-1]];
      let count = 0;

      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          if (!binary[i][j] || visited[i][j]) continue;
          count += 1;
          const queue = [[i, j]];
          visited[i][j] = true;
          while (queue.length) {
            const [x, y] = queue.pop();
            for (const [dx, dy] of dirs) {
              const nx = x + dx;
              const ny = y + dy;
              if (nx < 0 || ny < 0 || nx >= gridSize || ny >= gridSize) continue;
              if (binary[nx][ny] && !visited[nx][ny]) {
                visited[nx][ny] = true;
                queue.push([nx, ny]);
              }
            }
          }
        }
      }
      return count;
    }

    function computeBetti(source) {
      let mean = 0;
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          mean += source[i][j];
        }
      }
      mean /= (gridSize * gridSize);
      const binary = Array.from({ length: gridSize }, () => Array(gridSize).fill(false));
      const inverse = Array.from({ length: gridSize }, () => Array(gridSize).fill(false));
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          const on = source[i][j] > mean;
          binary[i][j] = on;
          inverse[i][j] = !on;
        }
      }
      const beta0 = countComponents(binary);
      const background = countComponents(inverse);
      const beta1 = Math.max(background - 1, 0);
      return { beta0, beta1 };
    }

    function updateStats() {
      let energy = 0;
      let mean = 0;
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          mean += field[i][j];
        }
      }
      mean /= (gridSize * gridSize);

      let variance = 0;
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          const grad = gradientMagnitude(field, i, j);
          energy += 0.5 * params.kappa * grad * grad + 0.25 * params.alpha * Math.pow(field[i][j], 4);
          variance += Math.pow(field[i][j] - mean, 2);
        }
      }
      variance /= (gridSize * gridSize);

      const energyRate = prevEnergy === null ? 0 : energy - prevEnergy;
      prevEnergy = energy;
      document.getElementById('energy').textContent = energy.toFixed(2);
      document.getElementById('energy-rate').textContent = energyRate.toFixed(4);
      document.getElementById('variance').textContent = variance.toFixed(4);

      const autocorr = prevField ? correlation(flattenField(field), flattenField(prevField)) : 0;
      document.getElementById('autocorr').textContent = autocorr.toFixed(3);
      prevField = field.map(row => row.slice());

      const betti = computeBetti(field);
      document.getElementById('betti-0').textContent = betti.beta0;
      document.getElementById('betti-1').textContent = betti.beta1;

      const warning = autocorr > 0.7 || variance > 0.1 ? "ELEVATED" : "LOW";
      document.getElementById('warning').textContent = warning;
    }

    // Event listeners
    document.getElementById('kappa').addEventListener('input', e => {
      params.kappa = parseFloat(e.target.value);
      document.getElementById('kappa-val').textContent = params.kappa.toFixed(4);
    });

    document.getElementById('lambda').addEventListener('input', e => {
      params.lambda = parseFloat(e.target.value);
      document.getElementById('lambda-val').textContent = params.lambda.toFixed(2);
    });

    document.getElementById('alpha').addEventListener('input', e => {
      params.alpha = parseFloat(e.target.value);
      document.getElementById('alpha-val').textContent = params.alpha.toFixed(1);
    });

    document.getElementById('dt').addEventListener('input', e => {
      params.dt = parseFloat(e.target.value);
      document.getElementById('dt-val').textContent = params.dt.toFixed(3);
    });

    document.getElementById('shock-mag').addEventListener('input', e => {
      document.getElementById('shock-mag-val').textContent = parseFloat(e.target.value).toFixed(1);
    });

    document.getElementById('steps').addEventListener('input', e => {
      document.getElementById('steps-val').textContent = e.target.value;
    });

    yearSelect.addEventListener('change', () => {
      if (useDataField) {
        setFieldFromYear(String(yearSelect.value));
      } else {
        initField();
      }
      drawField();
      updateStats();
    });

    colormapSelect.addEventListener('change', drawField);
    displayMode.addEventListener('change', drawField);

    document.getElementById('evolve-btn').addEventListener('click', () => {
      const steps = parseInt(document.getElementById('steps').value);
      evolveField(steps);
    });

    document.getElementById('reset-btn').addEventListener('click', () => {
      if (useDataField) {
        setFieldFromYear(String(yearSelect.value));
      } else {
        initField();
      }
      drawField();
      updateStats();
    });

    // Initial draw
    loadFieldData();

    console.log("üåç Topological Trade Dynamics initialized");
    console.log("Data-backed interface with fallback to synthetic fields");
  </script>
</body>
</html>
